<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIFX Home control</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter font for better aesthetics */
        :root {
            --bg-color: #111827; /* gray-900 */
            --card-bg-color: #1f2937; /* gray-800 */
            --text-color: #f9fafb; /* gray-50 */
            --muted-text-color: #9ca3af; /* gray-400 */
            --border-color: #374151; /* gray-700 */
            --primary-accent: #4f46e5; /* indigo-600 */
            --primary-accent-hover: #4338ca; /* indigo-700 */
        }

        .light-theme {
            --bg-color: #f3f4f6; /* gray-100 */
            --card-bg-color: #ffffff;
            --text-color: #111827; /* gray-900 */
            --muted-text-color: #4b5563; /* gray-600 */
            --border-color: #d1d5db; /* gray-300 */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        /* Custom styles for the color wheel canvas */
        #color-wheel-canvas {
            border-radius: 0.5rem;
            cursor: crosshair;
            touch-action: none;
        }

        /* Style for the brightness slider thumb */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px; /* Slightly larger thumb */
            height: 18px;
            border-radius: 50%;
            background: var(--primary-accent);
            cursor: pointer;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            border: 3px solid #e5e7eb; /* Light border for dark theme contrast */
        }
        input[type=range]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-accent);
            cursor: pointer;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            border: 3px solid #e5e7eb;
        }
        
        /* Thicker slider track definition */
        input[type=range]::-webkit-slider-runnable-track {
            height: 12px; /* Thicker track height */
            background: #4b5563; /* Gray-600 background for track */
            border-radius: 6px;
        }
        input[type=range]::-moz-range-track {
            height: 12px;
            background: #4b5563;
            border-radius: 6px;
        }

        /* Base light card background style */
        .light-card-bg {
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
            transition: background-color 0.3s, border-color 0.3s;
        }

        /* Overlay for color and brightness */
        .light-color-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transition: background-color 0.3s ease;
        }

        /* Tab styles */
        .tab-button {
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            background-color: transparent;
            color: var(--muted-text-color);
            border: 2px solid transparent;
        }

        .tab-button.active {
            background-color: var(--primary-accent);
            color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .tab-button:not(.active):hover {
            background-color: rgba(79, 70, 229, 0.1); /* indigo-600 with low opacity */
            color: var(--primary-accent);
        }

        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        .theme-toggle-button {
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 0.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .theme-toggle-button:hover {
            background-color: var(--border-color);
        }
    </style>
</head>
<body class="min-h-screen flex items-start justify-center p-4">
    <div class="p-8 rounded-xl shadow-2xl w-full max-w-6xl mt-6" style="background-color: var(--card-bg-color); border: 1px solid var(--border-color);">
        <div class="flex justify-between items-center mb-8">
            <h1 class="text-3xl font-bold text-center">LIFX Home Control</h1>
            <div class="flex items-center gap-2">
                <span class="text-sm font-medium" style="color: var(--muted-text-color);">Theme:</span>
                <select id="theme-switcher" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                    <option value="system">System</option>
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                </select>
            </div>
        </div>

        <!-- API Key Setup Section -->
        <div id="api-key-setup" class="mb-8 p-6 rounded-xl shadow-inner" style="background-color: var(--bg-color); border: 1px solid var(--border-color);">
            <h2 class="text-xl font-semibold mb-4">Personal Token Setup</h2>
            <p class="mb-4" style="color: var(--muted-text-color);">
                Your personal token is saved locally. You can generate a new one at 
                <a href="https://cloud.lifx.com/access_tokens" target="_blank" class="font-medium hover:underline" style="color: var(--primary-accent);">
                    cloud.lifx.com/access_tokens
                </a>.
            </p>
            <div class="flex flex-col sm:flex-row gap-4">
                <input type="password" id="api-key-input" placeholder="Enter your LIFX Personal Token"
                       class="flex-grow p-3 rounded-lg focus:outline-none focus:ring-2 transition duration-200"
                       style="border: 1px solid var(--border-color); background-color: var(--bg-color); color: var(--text-color);">
                <button id="save-api-key-btn"
                        class="text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105"
                        style="background-color: var(--primary-accent);">
                    Save Token & Fetch Lights
                </button>
            </div>
            <p id="api-key-status" class="mt-3 text-sm"></p>
        </div>

        <!-- Main Light Dashboard Section -->
        <div id="light-control-section" class="hidden">
            <!-- Tabs -->
            <div class="flex justify-center mb-6 border-b" style="border-color: var(--border-color);">
                <button id="tab-rooms" class="tab-button active">Rooms</button>
                <button id="tab-all-lights" class="tab-button">All Lights</button>
            </div>

            <!-- Tab Content -->
            <div id="tab-content-rooms" class="tab-content active">
                <div id="rooms-list" class="space-y-8">
                    <!-- Room sections will be loaded here dynamically -->
                </div>
                <p id="no-rooms-message" class="mt-8 hidden text-center p-4 rounded-lg" style="background-color: var(--bg-color); color: var(--muted-text-color);">No rooms found. Lights that are not in a group will not be displayed here.</p>
            </div>

            <div id="tab-content-all-lights" class="tab-content">
                <div id="lights-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                    <!-- Light cards will be loaded here dynamically -->
                </div>
                <p id="no-lights-message" class="mt-8 hidden text-center p-4 rounded-lg" style="background-color: var(--bg-color); color: var(--muted-text-color);">No LIFX lights found for this account. Please check your personal token.</p>
            </div>
            
            <!-- Footer Refresh Status -->
            <div id="refresh-status" class="text-center text-sm mt-8" style="color: var(--muted-text-color);"></div>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div id="color-picker-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center hidden z-50 p-4">
        <div class="p-6 rounded-xl shadow-2xl max-w-lg w-full" style="background-color: var(--card-bg-color); border: 1px solid var(--border-color);">
            <h3 class="text-xl font-bold mb-4">Set Color for <span id="modal-light-label" style="color: var(--primary-accent);"></span></h3>
            <div class="flex flex-col items-center">
                <canvas id="color-wheel-canvas" width="250" height="250" class="shadow-md mb-4"></canvas>
                <div class="flex justify-center items-center gap-4">
                    <span class="text-sm" style="color: var(--muted-text-color);">Selected Color:</span>
                    <div id="modal-selected-color-preview" class="w-16 h-8 rounded-md shadow-sm" style="background-color: #808080; border: 1px solid var(--border-color);"></div>
                </div>
                <button id="modal-close-btn" class="mt-6 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg w-full transition duration-300">Close</button>
            </div>
        </div>
    </div>

    <!-- Message Box for Alerts -->
    <div id="message-box" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="p-6 rounded-lg shadow-xl max-w-sm w-full" style="background-color: var(--card-bg-color); border: 1px solid var(--border-color);">
            <h3 id="message-box-title" class="text-lg font-bold mb-4"></h3>
            <p id="message-box-content" class="mb-6" style="color: var(--muted-text-color);"></p>
            <button id="message-box-close" class="font-bold py-2 px-4 rounded-lg w-full transition duration-300 ease-in-out" style="background-color: var(--primary-accent); color: white;">Close</button>
        </div>
    </div>

    <script>
        // Global variables
        let LIFX_API_KEY = localStorage.getItem('lifxApiKey') || '';
        let ALL_LIGHTS = [];
        let ACTIVE_LIGHT_ID = null; // Used for single light color changes
        let ACTIVE_ROOM_NAME = null; // Used for room-level color changes
        let refreshIntervalId;

        // --- Theme Management ---
        const themeSwitcher = document.getElementById('theme-switcher');
        const body = document.body;

        function applyTheme(theme) {
            if (theme === 'light') {
                body.classList.add('light-theme');
            } else {
                body.classList.remove('light-theme');
            }
        }

        function handleThemeChange() {
            const selectedTheme = themeSwitcher.value;
            localStorage.setItem('lifxTheme', selectedTheme);
            if (selectedTheme === 'system') {
                const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                applyTheme(systemPrefersDark ? 'dark' : 'light');
            } else {
                applyTheme(selectedTheme);
            }
        }
        
        // --- DOM Elements ---
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
        const apiKeyStatus = document.getElementById('api-key-status');
        const apiKeySetupSection = document.getElementById('api-key-setup');
        const lightControlSection = document.getElementById('light-control-section');
        const lightsListDiv = document.getElementById('lights-list');
        const roomsListDiv = document.getElementById('rooms-list');
        const noLightsMessage = document.getElementById('no-lights-message');
        const noRoomsMessage = document.getElementById('no-rooms-message');
        const messageBox = document.getElementById('message-box');
        const messageBoxTitle = document.getElementById('message-box-title');
        const messageBoxContent = document.getElementById('message-box-content');
        const messageBoxCloseBtn = document.getElementById('message-box-close');
        const refreshStatusSpan = document.getElementById('refresh-status');
        
        // Tab elements
        const tabRooms = document.getElementById('tab-rooms');
        const tabAllLights = document.getElementById('tab-all-lights');
        const tabContentRooms = document.getElementById('tab-content-rooms');
        const tabContentAllLights = document.getElementById('tab-content-all-lights');

        // Modal/Color Wheel Elements
        const colorPickerModal = document.getElementById('color-picker-modal');
        const modalLightLabel = document.getElementById('modal-light-label');
        const modalSelectedColorPreview = document.getElementById('modal-selected-color-preview');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const colorWheelCanvas = document.getElementById('color-wheel-canvas');
        const ctx = colorWheelCanvas.getContext('2d');
        let currentHue = 0;
        let currentSaturation = 1;
        let currentBrightness = 1;
        let isDraggingColorWheel = false;

        // --- Utility Functions ---

        /**
         * Displays a custom message box.
         */
        function showMessageBox(title, message) {
            messageBoxTitle.textContent = title;
            messageBoxContent.textContent = message;
            messageBox.classList.remove('hidden');
        }

        /**
         * Hides the custom message box.
         */
        function hideMessageBox() {
            messageBox.classList.add('hidden');
        }
        
        /**
         * Determines the best text color based on the light's brightness for contrast.
         */
        function getTextColorClass(brightness) {
            // If brightness is high (e.g., above 0.55), use dark gray text for light theme, slightly lighter for dark theme
            // Otherwise, use light white/gray text.
            const isLightTheme = body.classList.contains('light-theme');
            if (brightness > 0.55) {
                return isLightTheme ? 'text-gray-900' : 'text-gray-800';
            }
            return isLightTheme ? 'text-gray-50' : 'text-gray-100';
        }


        /**
         * Converts LIFX HSB to an RGB CSS string.
         */
        function hsbToRgbCss(h, s, b) {
            let r, g, bb;
            if (s === 0) {
                let val = Math.round(b * 255);
                return `rgb(${val}, ${val}, ${val})`;
            }
            h = h % 360;
            const i = Math.floor(h / 60);
            const f = h / 60 - i;
            const p = b * (1 - s);
            const q = b * (1 - s * f);
            const t = b * (1 - s * (1 - f));
            switch (i % 6) {
                case 0: r = b; g = t; bb = p; break;
                case 1: r = q; g = b; bb = p; break;
                case 2: r = p; g = b; bb = t; break;
                case 3: r = p; g = q; bb = b; break;
                case 4: r = t; g = p; bb = b; break;
                case 5: r = b; g = p; bb = q; break;
            }
            return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(bb * 255)})`;
        }

        // --- Color Wheel Functions ---

        /**
         * Draws the color wheel on the canvas.
         */
        function drawColorWheel() {
            const centerX = colorWheelCanvas.width / 2;
            const centerY = colorWheelCanvas.height / 2;
            const radius = Math.min(centerX, centerY) - 5;

            ctx.clearRect(0, 0, colorWheelCanvas.width, colorWheelCanvas.height);

            // Draw the hue ring
            for (let angle = 0; angle <= 360; angle += 1) {
                const startAngle = (angle - 1) * Math.PI / 180;
                const endAngle = angle * Math.PI / 180;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = `hsl(${angle}, 100%, 50%)`;
                ctx.fill();
            }

            // Draw saturation/brightness gradient
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.9, 'rgba(255,255,255,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.8)');
            ctx.fillStyle = gradient;
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fill();

            // Draw current selected color indicator
            const angleRad = currentHue * Math.PI / 180;
            const dist = radius * currentSaturation;
            const indicatorX = centerX + dist * Math.cos(angleRad);
            const indicatorY = centerY + dist * Math.sin(angleRad);
            
            ctx.beginPath();
            ctx.arc(indicatorX, indicatorY, 7, 0, 2 * Math.PI);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            const previewRgb = hsbToRgbCss(currentHue, currentSaturation, currentBrightness);
            ctx.fillStyle = previewRgb;
            ctx.fill();

            modalSelectedColorPreview.style.backgroundColor = previewRgb;
        }

        /**
         * Gets the HSB color from a given x, y coordinate on the color wheel.
         */
        function getColorFromWheel(x, y) {
            const centerX = colorWheelCanvas.width / 2;
            const centerY = colorWheelCanvas.height / 2;
            const radius = Math.min(centerX, centerY) - 5;
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > radius) return null;

            let hue = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
            let saturation = Math.min(distance / radius, 1);
            return { h: hue, s: saturation, b: 1.0 };
        }

        /**
         * Handles color selection on the color wheel and sends command.
         */
        function handleColorSelection(event) {
            const rect = colorWheelCanvas.getBoundingClientRect();
            let clientX, clientY;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const color = getColorFromWheel(x, y);

            if (color && (ACTIVE_LIGHT_ID || ACTIVE_ROOM_NAME)) {
                currentHue = color.h;
                currentSaturation = color.s;
                
                let target, originalBrightness;
                
                if (ACTIVE_LIGHT_ID) {
                    target = ALL_LIGHTS.find(l => l.id === ACTIVE_LIGHT_ID);
                    if (!target || target.power === 'off') return;
                    originalBrightness = target.brightness;
                } else { // Room control
                    target = { label: ACTIVE_ROOM_NAME };
                    const roomLights = ALL_LIGHTS.filter(l => l.group.name === ACTIVE_ROOM_NAME && l.power === 'on' && l.connected);
                    if (roomLights.length === 0) return;
                    // Use average brightness of the room's 'on' lights
                    const totalBrightness = roomLights.reduce((acc, l) => acc + l.brightness, 0);
                    originalBrightness = roomLights.length > 0 ? totalBrightness / roomLights.length : 1.0;
                }
                
                currentBrightness = originalBrightness;
                drawColorWheel();

                const selector = ACTIVE_LIGHT_ID ? `id:${ACTIVE_LIGHT_ID}` : `group:${ACTIVE_ROOM_NAME}`;
                const colorString = `hue:${currentHue} saturation:${currentSaturation} brightness:${originalBrightness}`;
                sendLightCommand(selector, { color: colorString, duration: 0.1 });

                // Optimistic update
                if (ACTIVE_LIGHT_ID) {
                    target.color.hue = currentHue;
                    target.color.saturation = currentSaturation;
                    target.power = 'on';
                    updateLightCardVisuals(ACTIVE_LIGHT_ID);
                } else {
                    ALL_LIGHTS.forEach(light => {
                        if (light.group.name === ACTIVE_ROOM_NAME && light.power === 'on') {
                            light.color.hue = currentHue;
                            light.color.saturation = currentSaturation;
                            updateLightCardVisuals(light.id);
                        }
                    });
                }
            }
        }
        
        /**
         * Opens the color picker modal for a specific light or room.
         */
        function openColorPicker(target, isRoom = false) {
            ACTIVE_LIGHT_ID = isRoom ? null : target.id;
            ACTIVE_ROOM_NAME = isRoom ? target.name : null;
            
            modalLightLabel.textContent = isRoom ? target.name : target.label;

            let initialHue = 0, initialSaturation = 0, initialBrightness = 1;

            if (isRoom) {
                const roomLightsOn = ALL_LIGHTS.filter(l => l.group.name === target.name && l.power === 'on' && l.connected);
                if (roomLightsOn.length > 0) {
                    // Average the color and brightness for the room
                    initialHue = roomLightsOn.reduce((sum, l) => sum + l.color.hue, 0) / roomLightsOn.length;
                    initialSaturation = roomLightsOn.reduce((sum, l) => sum + l.color.saturation, 0) / roomLightsOn.length;
                    initialBrightness = roomLightsOn.reduce((sum, l) => sum + l.brightness, 0) / roomLightsOn.length;
                }
            } else {
                 if (target.power !== 'on') return;
                if (target.color && target.color.hue !== undefined) {
                    initialHue = target.color.hue;
                    initialSaturation = target.color.saturation;
                    initialBrightness = target.brightness;
                }
            }

            currentHue = initialHue;
            currentSaturation = initialSaturation;
            currentBrightness = initialBrightness;

            drawColorWheel();
            colorPickerModal.classList.remove('hidden');
        }

        // --- LIFX API Interaction ---

        /**
         * Fetches all LIFX lights for the given API key.
         */
        async function fetchLights(isAutoRefresh = false) {
            if (!LIFX_API_KEY) {
                if (!isAutoRefresh) showMessageBox('API Key Required', 'Please enter your personal token to fetch lights.');
                return;
            }

            const statusTarget = isAutoRefresh ? refreshStatusSpan : apiKeyStatus;

            if (!isAutoRefresh) {
                statusTarget.textContent = 'Fetching lights...';
                statusTarget.style.color = 'var(--muted-text-color)';
            } else {
                statusTarget.textContent = `Refreshing...`;
            }

            try {
                const response = await fetch('https://api.lifx.com/v1/lights/all', {
                    headers: { 'Authorization': `Bearer ${LIFX_API_KEY}` }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`LIFX API Error: ${response.status} - ${errorData.error || 'Unknown error'}`);
                }

                ALL_LIGHTS = await response.json();
                displayLights(); // This will now render both tabs
                displayRooms();

                if (!isAutoRefresh) {
                    statusTarget.textContent = 'Lights fetched successfully!';
                    statusTarget.style.color = '#22c55e'; // green-500
                    apiKeySetupSection.classList.add('hidden');
                    lightControlSection.classList.remove('hidden');
                    startAutoRefresh();
                } else {
                    const now = new Date().toLocaleTimeString();
                    refreshStatusSpan.textContent = `Last refreshed: ${now}`;
                }

            } catch (error) {
                console.error('Error fetching lights:', error);
                if (!isAutoRefresh) {
                    showMessageBox('Failed to Fetch Lights', `There was an error fetching your LIFX lights. Please check your personal token and internet connection. Error: ${error.message}`);
                    statusTarget.textContent = 'Failed to fetch lights. Invalid Token or network issue.';
                    statusTarget.style.color = '#ef4444'; // red-500
                    ALL_LIGHTS = [];
                    displayLights();
                    displayRooms();
                    apiKeySetupSection.classList.remove('hidden');
                    lightControlSection.classList.add('hidden');
                } else {
                    const now = new Date().toLocaleTimeString();
                    refreshStatusSpan.textContent = `Refresh failed: ${now}`;
                }
            }
        }

        /**
         * Sends a state change command to a LIFX light or group.
         * Selector can be 'all', 'id:<light_id>', 'group:<group_name>', etc.
         */
        async function sendLightCommand(selector, payload) {
            if (!LIFX_API_KEY) {
                showMessageBox('API Key Missing', 'API key is not set. Please save your key.');
                return;
            }

            try {
                const response = await fetch(`https://api.lifx.com/v1/lights/${selector}/state`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${LIFX_API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`LIFX API Error: ${response.status} - ${errorData.error || 'Unknown error'}`);
                }
                console.log(`Command sent to ${selector}:`, payload);
            } catch (error) {
                console.error('Error sending light command:', error);
                showMessageBox('Command Failed', `Failed to send command. Error: ${error.message}`);
            }
        }
        
        // --- Auto-Refresh ---
        
        function startAutoRefresh() {
            if (refreshIntervalId) clearInterval(refreshIntervalId);
            refreshIntervalId = setInterval(() => fetchLights(true), 60000);
            const now = new Date().toLocaleTimeString();
            refreshStatusSpan.textContent = `Last refreshed: ${now}`;
        }


        // --- UI Rendering and Event Handlers ---

        /**
         * Updates the visual state of a single light card.
         */
        function updateLightCardVisuals(lightId) {
            const light = ALL_LIGHTS.find(l => l.id === lightId);
            if (!light) return;

            const card = document.getElementById(`card-${lightId}`);
            if (!card) return;

            const slider = document.getElementById(`brightness-slider-${lightId}`);
            const sliderContainer = document.getElementById(`slider-container-${lightId}`);
            const brightnessValue = document.getElementById(`brightness-value-${lightId}`);
            const colorOverlay = document.getElementById(`color-overlay-${lightId}`);
            const statusPillElement = document.getElementById(`status-pill-${lightId}`);
            const colorButton = document.getElementById(`color-button-${lightId}`);
            const lightNameElement = card.querySelector('h3');
            const brightnessLabelElement = card.querySelector(`#brightness-label-${lightId}`);

            card.classList.remove('opacity-50', 'cursor-not-allowed');
            card.style.cursor = 'pointer';

            // Reset text colors
            if (lightNameElement) lightNameElement.classList.remove('text-gray-100', 'text-gray-900', 'text-gray-800', 'text-gray-50');
            if (brightnessLabelElement) brightnessLabelElement.classList.remove('text-gray-100', 'text-gray-900', 'text-gray-800', 'text-gray-50');

            if (light.connected === false) {
                card.classList.add('opacity-50', 'cursor-not-allowed');
                sliderContainer.classList.add('hidden');
                colorOverlay.style.backgroundColor = 'transparent';
                colorOverlay.style.opacity = '0';
                statusPillElement.innerHTML = `<span class="text-xs font-semibold px-3 py-1 rounded-full bg-red-800 text-red-300 flex items-center gap-1"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8.257 3.34c.52-1.258 2.45-1.258 2.97 0l6.234 15.01c.52 1.258-.39 2.47-1.554 2.47H3.577c-1.164 0-2.074-1.212-1.554-2.47L8.257 3.34zM10 13a1 1 0 100-2 1 1 0 000 2zm0-5a1 1 0 00-1 1v2a1 1 0 102 0V9a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>OFFLINE</span>`;
                colorButton.classList.add('opacity-50', 'cursor-not-allowed');
                colorButton.classList.remove('hover:scale-105');
                if (lightNameElement) lightNameElement.classList.add('text-gray-100');
                if (brightnessLabelElement) brightnessLabelElement.classList.add('text-gray-100');
                return;
            }

            colorButton.classList.remove('opacity-50', 'cursor-not-allowed');
            colorButton.classList.add('hover:scale-105');

            if (light.power === 'off') {
                sliderContainer.classList.add('hidden');
                colorOverlay.style.backgroundColor = 'transparent';
                colorOverlay.style.opacity = '0';
                statusPillElement.innerHTML = `<span class="text-xs font-semibold px-3 py-1 rounded-full bg-red-800 text-red-300">OFF</span>`;
                colorButton.classList.add('opacity-50', 'cursor-not-allowed');
                colorButton.classList.remove('hover:scale-105');
                if (lightNameElement) lightNameElement.classList.add(body.classList.contains('light-theme') ? 'text-gray-900' : 'text-gray-100');
                 if (brightnessLabelElement) brightnessLabelElement.classList.add(body.classList.contains('light-theme') ? 'text-gray-900' : 'text-gray-100');

            } else {
                sliderContainer.classList.remove('hidden');
                statusPillElement.innerHTML = '';
                const brightnessPercent = Math.round(light.brightness * 100);
                if (slider) slider.value = brightnessPercent;
                brightnessValue.textContent = `${brightnessPercent}%`;

                const hue = light.color?.hue || 0;
                const sat = light.color?.saturation || 0;
                const brightness = light.brightness || 0;

                const overlayColor = hsbToRgbCss(hue, sat, brightness);
                colorOverlay.style.backgroundColor = overlayColor;
                colorOverlay.style.opacity = '1';
                
                const textColorClass = getTextColorClass(brightness);
                if (lightNameElement) lightNameElement.classList.add(textColorClass);
                if (brightnessLabelElement) brightnessLabelElement.classList.add(textColorClass);
                
                colorButton.onclick = () => openColorPicker(light);
            }
        }


        /**
         * Renders the HTML for a single light card.
         */
        function renderLightCard(light) {
            const isConnected = light.connected !== false;
            const isOff = light.power === 'off';
            const brightnessPercent = Math.round(light.brightness * 100);

            let initialPillHtml = '', sliderVisibility = 'hidden', initialTextColorClass = getTextColorClass(0);

            if (!isConnected) {
                initialPillHtml = `<span class="text-xs font-semibold px-3 py-1 rounded-full bg-red-800 text-red-300 flex items-center gap-1"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8.257 3.34c.52-1.258 2.45-1.258 2.97 0l6.234 15.01c.52 1.258-.39 2.47-1.554 2.47H3.577c-1.164 0-2.074-1.212-1.554-2.47L8.257 3.34zM10 13a1 1 0 100-2 1 1 0 000 2zm0-5a1 1 0 00-1 1v2a1 1 0 102 0V9a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>OFFLINE</span>`;
            } else if (isOff) {
                initialPillHtml = `<span class="text-xs font-semibold px-3 py-1 rounded-full bg-red-800 text-red-300">OFF</span>`;
            } else {
                sliderVisibility = '';
                initialTextColorClass = getTextColorClass(light.brightness);
            }

            let initialColorStyle = 'transparent';
            let initialOpacity = '0';
            if (isConnected && !isOff) {
                initialColorStyle = hsbToRgbCss(light.color?.hue || 0, light.color?.saturation || 0, light.brightness || 0);
                initialOpacity = '1';
            }

            return `
                <div id="card-${light.id}"
                     data-light-id="${light.id}"
                     class="light-card-bg p-5 rounded-xl transform hover:scale-[1.01] transition-all duration-300 ${!isConnected ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}">
                    
                    <div id="color-overlay-${light.id}" class="light-color-overlay rounded-xl" style="background-color: ${initialColorStyle}; opacity: ${initialOpacity};"></div>

                    <div class="relative z-10 space-y-3">
                        <div class="flex justify-between items-center mb-3">
                            <div id="status-pill-${light.id}">${initialPillHtml}</div>
                        </div>

                        <div class="flex items-center justify-between">
                            <h3 class="text-xl font-bold ${initialTextColorClass} truncate pr-2">${light.label}</h3>
                            <button id="color-button-${light.id}" data-light-id="${light.id}" title="Set Colour"
                                    class="p-2 w-10 h-10 rounded-full shadow-md transition duration-300 ease-in-out inline-flex items-center justify-center ${isOff || !isConnected ? 'opacity-50 cursor-not-allowed' : 'hover:scale-105'}"
                                    style="background-color: var(--primary-accent);">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a10 10 0 1 0 10 10a10 10 0 0 0-10-10z"/><path d="M18 10a6 6 0 0 0-6-6v6h6z"/><path d="M12 18a6 6 0 0 1-6-6h6z"/></svg>
                            </button>
                        </div>
                        
                        <div id="slider-container-${light.id}" class="${sliderVisibility}">
                            <label for="brightness-slider-${light.id}" id="brightness-label-${light.id}" class="block text-sm font-medium ${initialTextColorClass} mb-2">
                                Brightness: <span id="brightness-value-${light.id}">${brightnessPercent}%</span>
                            </label>
                            <input type="range" id="brightness-slider-${light.id}" min="0" max="100" value="${brightnessPercent}"
                                   data-light-id="${light.id}"
                                   class="w-full h-3 bg-gray-600 rounded-lg appearance-none cursor-pointer transition duration-200">
                        </div>
                    </div>
                </div>
            `;
        }

        /**
         * Renders the HTML for a single room control section.
         */
        function renderRoomSection(roomName, lightsInRoom) {
            const connectedLights = lightsInRoom.filter(l => l.connected);
            const onLights = connectedLights.filter(l => l.power === 'on');
            const avgBrightness = onLights.length > 0 ? Math.round(onLights.reduce((sum, l) => sum + l.brightness, 0) / onLights.length * 100) : 0;
            const isAllOff = onLights.length === 0;

            let roomColorStyle = 'transparent';
            if (!isAllOff) {
                const avgHue = onLights.reduce((sum, l) => sum + l.color.hue, 0) / onLights.length;
                const avgSat = onLights.reduce((sum, l) => sum + l.color.saturation, 0) / onLights.length;
                const avgBrightnessValue = onLights.reduce((sum, l) => sum + l.brightness, 0) / onLights.length;
                roomColorStyle = hsbToRgbCss(avgHue, avgSat, avgBrightnessValue);
            }
            
            return `
                <div id="room-section-${roomName.replace(/\s+/g, '-')}" class="p-6 rounded-xl" style="background-color: var(--bg-color); border: 1px solid var(--border-color);">
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4">
                        <h3 class="text-2xl font-bold mb-3 sm:mb-0">${roomName}</h3>
                        <div class="flex items-center gap-3">
                            <span class="text-sm font-medium" style="color: var(--muted-text-color);">All Lights:</span>
                            <button title="Toggle Room Power" data-room-name="${roomName}" class="room-power-toggle p-2 w-10 h-10 rounded-full shadow-md transition transform hover:scale-105 ${isAllOff ? 'bg-gray-600' : 'bg-green-500'}">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white mx-auto" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9 5a1 1 0 112 0v5a1 1 0 11-2 0V5z" clip-rule="evenodd" /></svg>
                            </button>
                            <button title="Set Room Colour" data-room-name="${roomName}" class="room-color-picker p-2 w-10 h-10 rounded-full shadow-md transition transform hover:scale-105" style="background-color: ${isAllOff ? 'var(--border-color)' : roomColorStyle};">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white mx-auto" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a10 10 0 1 0 10 10a10 10 0 0 0-10-10z"/><path d="M18 10a6 6 0 0 0-6-6v6h6z"/><path d="M12 18a6 6 0 0 1-6-6h6z"/></svg>
                            </button>
                        </div>
                    </div>
                    <div id="room-slider-container-${roomName.replace(/\s+/g, '-')}" class="${isAllOff ? 'hidden' : ''}">
                          <label class="block text-sm font-medium mb-2" style="color: var(--muted-text-color);">
                            Room Brightness: <span id="room-brightness-value-${roomName.replace(/\s+/g, '-')}">${avgBrightness}%</span>
                          </label>
                          <input type="range" data-room-name="${roomName}" min="0" max="100" value="${avgBrightness}" class="w-full h-3 bg-gray-600 rounded-lg appearance-none cursor-pointer room-brightness-slider">
                    </div>
                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 mt-4">
                        ${lightsInRoom.map(renderLightCard).join('')}
                    </div>
                </div>
            `;
        }

        /**
         * Groups lights by room and displays them, with a special layout for small rooms.
         */
        function displayRooms() {
            const rooms = ALL_LIGHTS.reduce((acc, light) => {
                const roomName = light.group?.name;
                if (roomName) {
                    if (!acc[roomName]) acc[roomName] = [];
                    acc[roomName].push(light);
                }
                return acc;
            }, {});

            roomsListDiv.innerHTML = ''; // Clear existing content
            const sortedRoomNames = Object.keys(rooms).sort();

            if (sortedRoomNames.length === 0) {
                noRoomsMessage.classList.remove('hidden');
                return;
            }
            noRoomsMessage.classList.add('hidden');

            const largeRooms = [];
            const smallRooms = [];

            sortedRoomNames.forEach(roomName => {
                // Ensure lights are sorted within the room for consistent order
                const lightsInRoom = rooms[roomName].sort((a, b) => a.label.localeCompare(b.label));
                if (lightsInRoom.length < 3) {
                    smallRooms.push({ name: roomName, lights: lightsInRoom });
                } else {
                    largeRooms.push({ name: roomName, lights: lightsInRoom });
                }
            });

            let finalHtml = '';

            // Render large rooms, which will be affected by the parent's `space-y-8`
            largeRooms.forEach(room => {
                finalHtml += renderRoomSection(room.name, room.lights);
            });

            // Render small rooms inside a single 2-column grid container
            if (smallRooms.length > 0) {
                let smallRoomsHtml = '<div class="grid grid-cols-1 md:grid-cols-2 gap-8">';
                smallRooms.forEach(room => {
                    smallRoomsHtml += renderRoomSection(room.name, room.lights);
                });
                smallRoomsHtml += '</div>';

                // Add the grid to the final HTML
                finalHtml += smallRoomsHtml;
            }

            roomsListDiv.innerHTML = finalHtml;
            
            // Add event listeners for all room controls after rendering
            document.querySelectorAll('.room-power-toggle').forEach(btn => {
                btn.addEventListener('click', () => handleRoomPowerToggle(btn.dataset.roomName));
            });
            document.querySelectorAll('.room-color-picker').forEach(btn => {
                btn.addEventListener('click', () => {
                    const roomName = btn.dataset.roomName;
                    const onLights = ALL_LIGHTS.filter(l => l.group.name === roomName && l.power === 'on');
                    if (onLights.length > 0) {
                        openColorPicker({ name: roomName }, true);
                    } else {
                        showMessageBox('Room is Off', `Please turn on at least one light in ${roomName} to set the room's color.`);
                    }
                });
            });
             document.querySelectorAll('.room-brightness-slider').forEach(slider => {
                slider.addEventListener('input', (e) => handleRoomBrightnessChange(e.target.dataset.roomName, e.target.value));
                slider.addEventListener('change', (e) => handleRoomBrightnessApply(e.target.dataset.roomName, e.target.value));
            });

            // Add event listeners for the individual light cards rendered within the rooms
            [...largeRooms, ...smallRooms].forEach(room => {
                room.lights.forEach(light => {
                    const card = document.getElementById(`card-${light.id}`);
                    const slider = document.getElementById(`brightness-slider-${light.id}`);
                    const colorButton = document.getElementById(`color-button-${light.id}`);

                    if (card && light.connected !== false) {
                        card.addEventListener('click', (e) => {
                            if (e.target.closest('input[type="range"]') || e.target.closest('button')) return;
                            const newPowerState = light.power === 'on' ? 'off' : 'on';
                            handlePowerToggle(light.id, newPowerState);
                        });
                    }
                    if (slider) {
                        slider.addEventListener('input', (e) => handleBrightnessChange(light.id, e.target.value));
                        slider.addEventListener('change', (e) => handleBrightnessApply(light.id, e.target.value));
                    }
                    if (colorButton && light.connected !== false) {
                        colorButton.addEventListener('click', () => {
                            const currentLight = ALL_LIGHTS.find(l => l.id === light.id);
                            if (currentLight.power === 'on') {
                                openColorPicker(currentLight);
                            } else {
                                showMessageBox('Light is Off', `Please turn on ${currentLight.label} before setting its colour.`);
                            }
                        });
                    }
                });
            });
        }

        /**
         * Displays all lights in the "All Lights" tab.
         */
        function displayLights() {
            lightsListDiv.innerHTML = ''; 

            if (ALL_LIGHTS.length === 0) {
                noLightsMessage.classList.remove('hidden');
                return;
            }
            noLightsMessage.classList.add('hidden');

            ALL_LIGHTS.sort((a, b) => a.label.localeCompare(b.label)).forEach(light => {
                lightsListDiv.innerHTML += renderLightCard(light);
            });

            // Add event listeners after all cards are rendered
            ALL_LIGHTS.forEach(light => {
                const card = document.getElementById(`card-${light.id}`);
                const slider = document.getElementById(`brightness-slider-${light.id}`);
                const colorButton = document.getElementById(`color-button-${light.id}`);

                if (card && light.connected !== false) {
                    card.addEventListener('click', (e) => {
                        if (e.target.closest('input[type="range"]') || e.target.closest('button')) return;
                        const newPowerState = light.power === 'on' ? 'off' : 'on';
                        handlePowerToggle(light.id, newPowerState);
                    });
                }
                if (slider) {
                    slider.addEventListener('input', (e) => handleBrightnessChange(light.id, e.target.value));
                    slider.addEventListener('change', (e) => handleBrightnessApply(light.id, e.target.value));
                }
                if (colorButton && light.connected !== false) {
                    colorButton.addEventListener('click', () => {
                        const currentLight = ALL_LIGHTS.find(l => l.id === light.id);
                        if (currentLight.power === 'on') {
                            openColorPicker(currentLight);
                        } else {
                             showMessageBox('Light is Off', `Please turn on ${currentLight.label} before setting its colour.`);
                        }
                    });
                }
            });
        }
        
        /**
         * Handles room power toggle.
         */
        async function handleRoomPowerToggle(roomName) {
            const roomLights = ALL_LIGHTS.filter(l => l.group.name === roomName && l.connected);
            if (roomLights.length === 0) return;

            const areAnyOn = roomLights.some(l => l.power === 'on');
            const newState = areAnyOn ? 'off' : 'on';

            // Optimistic Update
            roomLights.forEach(light => {
                light.power = newState;
                updateLightCardVisuals(light.id);
            });
            updateRoomControls(roomName);

            await sendLightCommand(`group:${roomName}`, { power: newState, duration: 0.5 });
        }

        /**
         * Handles room brightness change (UI only).
         */
        function handleRoomBrightnessChange(roomName, value) {
            const brightnessValueSpan = document.getElementById(`room-brightness-value-${roomName.replace(/\s+/g, '-')}`);
            if(brightnessValueSpan) brightnessValueSpan.textContent = `${value}%`;

            const newBrightness = value / 100;
            ALL_LIGHTS.forEach(light => {
                if (light.group.name === roomName && light.power === 'on') {
                    handleBrightnessChange(light.id, value);
                }
            });
        }
        
        /**
         * Handles room brightness apply (API call).
         */
        async function handleRoomBrightnessApply(roomName, value) {
            const brightness = value / 100;
            let payload = { brightness: brightness, duration: 0.2 };

            // If we are turning brightness up from 0, also turn power on.
            const roomLights = ALL_LIGHTS.filter(l => l.group.name === roomName && l.connected);
            const wereAllOff = roomLights.every(l => l.power === 'off');
            if (wereAllOff && brightness > 0) {
                 payload.power = 'on';
                 // Optimistic update
                 roomLights.forEach(l => {
                     l.power = 'on';
                     updateLightCardVisuals(l.id);
                 });
                 updateRoomControls(roomName);
            }
            
            await sendLightCommand(`group:${roomName}`, payload);
        }
        
        /**
         * Updates a room's master controls based on the state of its lights.
         */
        function updateRoomControls(roomName) {
            const roomLights = ALL_LIGHTS.filter(l => l.group.name === roomName && l.connected);
            const onLights = roomLights.filter(l => l.power === 'on');
            const isAllOff = onLights.length === 0;

            const powerBtn = document.querySelector(`.room-power-toggle[data-room-name="${roomName}"]`);
            const colorBtn = document.querySelector(`.room-color-picker[data-room-name="${roomName}"]`);
            const sliderContainer = document.getElementById(`room-slider-container-${roomName.replace(/\s+/g, '-')}`);
            const slider = sliderContainer?.querySelector('.room-brightness-slider');
            const brightnessValue = document.getElementById(`room-brightness-value-${roomName.replace(/\s+/g, '-')}`);
            
            if (!powerBtn || !colorBtn || !sliderContainer) return;
            
            powerBtn.classList.toggle('bg-gray-600', isAllOff);
            powerBtn.classList.toggle('bg-green-500', !isAllOff);
            
            if (isAllOff) {
                colorBtn.style.backgroundColor = 'var(--border-color)';
                sliderContainer.classList.add('hidden');
            } else {
                const avgHue = onLights.reduce((sum, l) => sum + l.color.hue, 0) / onLights.length;
                const avgSat = onLights.reduce((sum, l) => sum + l.color.saturation, 0) / onLights.length;
                const avgBrightness = onLights.reduce((sum, l) => sum + l.brightness, 0) / onLights.length;
                colorBtn.style.backgroundColor = hsbToRgbCss(avgHue, avgSat, avgBrightness);
                sliderContainer.classList.remove('hidden');
                if(slider) slider.value = Math.round(avgBrightness * 100);
                if(brightnessValue) brightnessValue.textContent = `${Math.round(avgBrightness * 100)}%`;
            }
        }


        /**
         * Handles light power toggle.
         */
        async function handlePowerToggle(lightId, newState) {
            const light = ALL_LIGHTS.find(l => l.id === lightId);
            if (!light || light.connected === false) return;

            // Optimistic update
            light.power = newState;
            if (newState === 'off') light.brightness = 0;
            
            let payload = { power: newState, duration: 0.3 };
            if (newState === 'on' && light.brightness === 0) {
                 payload.brightness = 1.0;
                 light.brightness = 1.0; 
            }
            updateLightCardVisuals(lightId);
            if(light.group.name) updateRoomControls(light.group.name);
            
            await sendLightCommand(`id:${lightId}`, payload);
            // Re-update after command in case something changed (e.g. brightness)
            updateLightCardVisuals(lightId);
             if(light.group.name) updateRoomControls(light.group.name);
        }

        /**
         * Handles immediate slider movement update (UI only).
         */
        function handleBrightnessChange(lightId, value) {
            const card = document.getElementById(`card-${lightId}`);
            if(!card) return;
            const brightnessValue = document.getElementById(`brightness-value-${lightId}`);
            const colorOverlay = document.getElementById(`color-overlay-${lightId}`);
            const lightNameElement = card.querySelector('h3');
            const brightnessLabelElement = card.querySelector(`#brightness-label-${lightId}`);

            if (brightnessValue) brightnessValue.textContent = `${value}%`;

            const light = ALL_LIGHTS.find(l => l.id === lightId);
            if (light) {
                const newBrightness = value / 100;
                light.brightness = newBrightness;
                
                const hue = light.color?.hue || 0;
                const sat = light.color?.saturation || 0;
                colorOverlay.style.backgroundColor = hsbToRgbCss(hue, sat, light.brightness);
                
                const newTextColorClass = getTextColorClass(light.brightness);
                
                lightNameElement.className = `text-xl font-bold ${newTextColorClass} truncate pr-2`;
                if (brightnessLabelElement) {
                     brightnessLabelElement.className = `block text-sm font-medium ${newTextColorClass} mb-2`;
                }
                 if(light.group.name) updateRoomControls(light.group.name);
            }
        }

        /**
         * Handles brightness value application (API call).
         */
        async function handleBrightnessApply(lightId, value) {
            const brightness = value / 100;
            const light = ALL_LIGHTS.find(l => l.id === lightId);
            let payload = { brightness: brightness, duration: 0.2 };

            if (light.power === 'off' && brightness > 0) {
                payload.power = 'on';
                light.power = 'on'; 
                updateLightCardVisuals(lightId); 
            }
            
            await sendLightCommand(`id:${lightId}`, payload);
        }

        // --- Event Listener Setup ---

        // Save API Key button click
        saveApiKeyBtn.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            if (key) {
                LIFX_API_KEY = key;
                localStorage.setItem('lifxApiKey', LIFX_API_KEY);
                fetchLights();
            } else {
                showMessageBox('Token Empty', 'Please enter your LIFX personal token before saving.');
            }
        });

        // Close message box
        messageBoxCloseBtn.addEventListener('click', hideMessageBox);

        // Modal Controls
        modalCloseBtn.addEventListener('click', () => {
            colorPickerModal.classList.add('hidden');
            ACTIVE_LIGHT_ID = null;
            ACTIVE_ROOM_NAME = null;
        });

        // Color Wheel Events
        colorWheelCanvas.addEventListener('mousedown', (e) => { isDraggingColorWheel = true; handleColorSelection(e); });
        colorWheelCanvas.addEventListener('mousemove', (e) => { if (isDraggingColorWheel) handleColorSelection(e); });
        colorWheelCanvas.addEventListener('mouseup', () => { isDraggingColorWheel = false; });
        colorWheelCanvas.addEventListener('mouseleave', () => { isDraggingColorWheel = false; });
        colorWheelCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); isDraggingColorWheel = true; handleColorSelection(e); }, { passive: false });
        colorWheelCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); if (isDraggingColorWheel) handleColorSelection(e); }, { passive: false });
        colorWheelCanvas.addEventListener('touchend', () => { isDraggingColorWheel = false; });
        colorWheelCanvas.addEventListener('touchcancel', () => { isDraggingColorWheel = false; });
        
        // Tab switching
        tabRooms.addEventListener('click', () => {
            tabRooms.classList.add('active');
            tabAllLights.classList.remove('active');
            tabContentRooms.classList.add('active');
            tabContentAllLights.classList.remove('active');
        });

        tabAllLights.addEventListener('click', () => {
            tabAllLights.classList.add('active');
            tabRooms.classList.remove('active');
            tabContentAllLights.classList.add('active');
            tabContentRooms.classList.remove('active');
        });

        // Theme switcher
        themeSwitcher.addEventListener('change', handleThemeChange);

        // --- Initialization ---

        window.onload = () => {
            // Apply saved theme or system preference
            const savedTheme = localStorage.getItem('lifxTheme') || 'system';
            themeSwitcher.value = savedTheme;
            handleThemeChange();
             window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', handleThemeChange);

            if (LIFX_API_KEY) {
                apiKeyInput.value = LIFX_API_KEY;
                fetchLights();
            }
        };
    </script>
</body>
</html>