<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIFX Home control</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter font for better aesthetics */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom styles for the color wheel canvas */
        #color-wheel-canvas {
            border-radius: 0.5rem;
            cursor: crosshair;
            touch-action: none;
        }

        /* Style for the brightness slider thumb */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px; /* Slightly larger thumb */
            height: 18px;
            border-radius: 50%;
            background: #8b5cf6; /* Tailwind purple-600 */
            cursor: pointer;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            border: 3px solid #e5e7eb; /* Light border for dark theme contrast */
        }
        input[type=range]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #8b5cf6;
            cursor: pointer;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            border: 3px solid #e5e7eb;
        }
        
        /* Thicker slider track definition */
        input[type=range]::-webkit-slider-runnable-track {
            height: 12px; /* Thicker track height */
            background: #4b5563; /* Gray-600 background for track */
            border-radius: 6px;
        }
        input[type=range]::-moz-range-track {
            height: 12px;
            background: #4b5563;
            border-radius: 6px;
        }

        /* Base light card background style */
        .light-card-bg {
            background-color: #374151; /* Gray-700 fallback */
            position: relative;
            overflow: hidden;
        }

        /* Overlay for color and brightness - NO MIX-BLEND-MODE */
        .light-color-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to go through to the card */
            transition: background-color 0.3s ease; 
        }
    </style>
</head>
<body class="bg-gray-900 min-h-screen flex items-start justify-center p-4">
    <div class="bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-5xl border border-gray-700 mt-6">
        <h1 class="text-3xl font-bold text-center text-white mb-8">LIFX Home control</h1>

        <!-- API Key Setup Section -->
        <div id="api-key-setup" class="mb-8 p-6 bg-gray-700 rounded-xl shadow-inner border border-gray-600">
            <h2 class="text-xl font-semibold text-white mb-4">LIFX API Key Setup</h2>
            <p class="text-gray-300 mb-4">Your API key is saved locally. You can generate a new one at <a href="https://cloud.lifx.com/settings" target="_blank" class="text-blue-400 hover:underline font-medium">cloud.lifx.com/settings</a>.</p>
            <div class="flex flex-col sm:flex-row gap-4">
                <input type="password" id="api-key-input" placeholder="Enter your LIFX API Key"
                       class="flex-grow p-3 border border-gray-600 bg-gray-900 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200">
                <button id="save-api-key-btn"
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                    Save Key & Fetch Lights
                </button>
            </div>
            <p id="api-key-status" class="mt-3 text-sm text-gray-400"></p>
        </div>

        <!-- Main Light Dashboard Section -->
        <div id="light-control-section" class="hidden">
            <h2 class="text-2xl font-semibold text-white mb-6 flex justify-between items-center">
                Device Dashboard
                <span id="refresh-status" class="text-sm text-gray-400"></span>
            </h2>
            <div id="lights-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                <!-- Light cards will be loaded here dynamically -->
            </div>
            <p id="no-lights-message" class="text-gray-400 mt-8 hidden text-center p-4 bg-gray-700 rounded-lg">No LIFX lights found for this account. Please check your API key.</p>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div id="color-picker-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl max-w-lg w-full border border-gray-700">
            <h3 class="text-xl font-bold text-white mb-4">Set Color for <span id="modal-light-label" class="text-purple-400"></span></h3>

            <div class="flex flex-col items-center">
                <canvas id="color-wheel-canvas" width="250" height="250" class="shadow-md mb-4"></canvas>
                <div class="flex justify-center items-center gap-4">
                    <span class="text-sm text-gray-300">Selected Color:</span>
                    <div id="modal-selected-color-preview" class="w-16 h-8 rounded-md border border-gray-600 shadow-sm" style="background-color: #808080;"></div>
                </div>
                <button id="modal-close-btn" class="mt-6 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg w-full transition duration-300">Close</button>
            </div>
        </div>
    </div>

    <!-- Message Box for Alerts -->
    <div id="message-box" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm w-full border border-gray-700">
            <h3 id="message-box-title" class="text-lg font-bold mb-4 text-white"></h3>
            <p id="message-box-content" class="text-gray-300 mb-6"></p>
            <button id="message-box-close" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg w-full transition duration-300 ease-in-out">Close</button>
        </div>
    </div>

    <script>
        // Global variables
        let LIFX_API_KEY = localStorage.getItem('lifxApiKey') || '';
        let ALL_LIGHTS = [];
        let ACTIVE_LIGHT_ID = null; // Used to track which light is being colored in the modal
        let refreshIntervalId; // For automatic status refresh

        // DOM Elements
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
        const apiKeyStatus = document.getElementById('api-key-status');
        const apiKeySetupSection = document.getElementById('api-key-setup');
        const lightControlSection = document.getElementById('light-control-section');
        const lightsListDiv = document.getElementById('lights-list');
        const noLightsMessage = document.getElementById('no-lights-message');
        const messageBox = document.getElementById('message-box');
        const messageBoxTitle = document.getElementById('message-box-title');
        const messageBoxContent = document.getElementById('message-box-content');
        const messageBoxCloseBtn = document.getElementById('message-box-close');
        const refreshStatusSpan = document.getElementById('refresh-status');

        // Modal/Color Wheel Elements
        const colorPickerModal = document.getElementById('color-picker-modal');
        const modalLightLabel = document.getElementById('modal-light-label');
        const modalSelectedColorPreview = document.getElementById('modal-selected-color-preview');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const colorWheelCanvas = document.getElementById('color-wheel-canvas');
        const ctx = colorWheelCanvas.getContext('2d');
        let currentHue = 0;
        let currentSaturation = 1;
        let currentBrightness = 1; // Internal brightness for color wheel selection
        let isDraggingColorWheel = false;

        // --- Utility Functions ---

        /**
         * Displays a custom message box instead of alert().
         */
        function showMessageBox(title, message) {
            messageBoxTitle.textContent = title;
            messageBoxContent.textContent = message;
            messageBox.classList.remove('hidden');
        }

        /**
         * Hides the custom message box.
         */
        function hideMessageBox() {
            messageBox.classList.add('hidden');
        }
        
        /**
         * Determines the best text color based on the light's brightness for contrast.
         * We use the LIFX brightness (0.0 to 1.0).
         */
        function getTextColorClass(brightness) {
            // If brightness is high (e.g., above 0.55), use dark gray text.
            // Otherwise, use light white text.
            return brightness > 0.55 ? 'text-gray-900' : 'text-gray-100';
        }


        /**
         * Converts LIFX HSB (Hue 0-360, Saturation 0-1, Brightness 0-1) to an RGB CSS string.
         * This function reflects the light's EXACT color and brightness for the dashboard background.
         */
        function hsbToRgbCss(h, s, b) {
            // HSB to RGB standard conversion
            let r, g, bb;
            
            if (s === 0) {
                // Achromatic (white/grey)
                let val = Math.round(b * 255);
                return `rgb(${val}, ${val}, ${val})`;
            }

            h = h % 360; // Ensure hue is 0-360
            
            const i = Math.floor(h / 60);
            const f = h / 60 - i;
            const p = b * (1 - s);
            const q = b * (1 - s * f);
            const t = b * (1 - s * (1 - f));
            
            switch (i % 6) {
                case 0: r = b; g = t; bb = p; break;
                case 1: r = q; g = b; bb = p; break;
                case 2: r = p; g = b; bb = t; break;
                case 3: r = p; g = q; bb = b; break;
                case 4: r = t; g = p; bb = b; break;
                case 5: r = b; g = p; bb = q; break;
            }
            
            return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(bb * 255)})`;
        }
        
        /**
         * Converts HSL color to RGB. (Used only for color wheel selector preview, HSL is easier to manage here)
         */
        function hslToRgb(h, s, l) {
            s = s; // saturation 0-1
            l = l; // lightness 0-1
            let c = (1 - Math.abs(2 * l - 1)) * s,
                x = c * (1 - Math.abs((h / 60) % 2 - 1)),
                m = l - c / 2,
                r = 0, g = 0, b = 0;

            if (0 <= h && h < 60) { r = c; g = x; b = 0; }
            else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
            else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
            else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
            else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
            else if (300 <= h && h < 360) { r = c; g = 0; b = x; }
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);
            return { r, g, b };
        }

        // --- Color Wheel Functions ---

        /**
         * Draws the color wheel on the canvas.
         */
        function drawColorWheel() {
            const centerX = colorWheelCanvas.width / 2;
            const centerY = colorWheelCanvas.height / 2;
            const radius = Math.min(centerX, centerY) - 5;

            ctx.clearRect(0, 0, colorWheelCanvas.width, colorWheelCanvas.height);

            // Draw the hue ring
            for (let angle = 0; angle <= 360; angle += 1) {
                const startAngle = (angle - 1) * Math.PI / 180;
                const endAngle = angle * Math.PI / 180;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = `hsl(${angle}, 100%, 50%)`;
                ctx.fill();
            }

            // Draw saturation/brightness gradient
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.9, 'rgba(255,255,255,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.8)');

            ctx.fillStyle = gradient;
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fill();

            // Draw current selected color indicator
            const angleRad = currentHue * Math.PI / 180;
            const dist = radius * currentSaturation;
            const indicatorX = centerX + dist * Math.cos(angleRad);
            const indicatorY = centerY + dist * Math.sin(angleRad);
            
            // Calculate lightness from currentBrightness (0 to 1) for HSL preview (LIFX B=1 maps roughly to HSL L=0.5 when S=1)
            const lightness = currentBrightness * 0.5; 

            ctx.beginPath();
            ctx.arc(indicatorX, indicatorY, 7, 0, 2 * Math.PI);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            // Use HSB to RGB for the preview color inside the wheel dot
            const previewRgb = hsbToRgbCss(currentHue, currentSaturation, currentBrightness);
            ctx.fillStyle = previewRgb;
            ctx.fill();

            modalSelectedColorPreview.style.backgroundColor = previewRgb;
        }

        /**
         * Gets the HSB color from a given x, y coordinate on the color wheel.
         */
        function getColorFromWheel(x, y) {
            const centerX = colorWheelCanvas.width / 2;
            const centerY = colorWheelCanvas.height / 2;
            const radius = Math.min(centerX, centerY) - 5;

            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > radius) {
                return null;
            }

            let hue = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
            let saturation = Math.min(distance / radius, 1);
            
            // Brightness is ignored here as it should be pulled from the light's current state later
            let brightness = 1.0; 

            return { h: hue, s: saturation, b: brightness };
        }

        /**
         * Handles color selection on the color wheel and sends command.
         */
        function handleColorSelection(event) {
            const rect = colorWheelCanvas.getBoundingClientRect();
            let clientX, clientY;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const color = getColorFromWheel(x, y);

            if (color && ACTIVE_LIGHT_ID) {
                const light = ALL_LIGHTS.find(l => l.id === ACTIVE_LIGHT_ID);
                if (!light || light.power === 'off') return;

                // FIX 1: Capture and use the original brightness level
                const originalBrightness = light.brightness;
                
                currentHue = color.h;
                currentSaturation = color.s;
                currentBrightness = originalBrightness; // Use original brightness for the modal preview

                // Update wheel visually
                drawColorWheel();

                // Send color command using the original brightness value
                const colorString = `hue:${currentHue} saturation:${currentSaturation} brightness:${originalBrightness}`;
                sendLightCommand(ACTIVE_LIGHT_ID, { color: colorString, duration: 0.1 });

                // Update the local light state (optimistic update)
                light.color.hue = currentHue;
                light.color.saturation = currentSaturation;
                light.power = 'on'; 
                // light.brightness is already set to originalBrightness

                updateLightCardVisuals(ACTIVE_LIGHT_ID);
            }
        }

        /**
         * Opens the color picker modal for a specific light.
         */
        function openColorPicker(light) {
            if (light.power !== 'on') return; // Only open for ON lights

            ACTIVE_LIGHT_ID = light.id;
            modalLightLabel.textContent = light.label;

            // Initialize wheel to current light color
            if (light.color && light.color.hue !== undefined) {
                currentHue = light.color.hue;
                currentSaturation = light.color.saturation;
                currentBrightness = light.brightness; // Load current brightness
            } else {
                currentHue = 0;
                currentSaturation = 0;
                currentBrightness = 1;
            }

            drawColorWheel();
            colorPickerModal.classList.remove('hidden');
        }

        // --- LIFX API Interaction ---

        /**
         * Fetches all LIFX lights for the given API key.
         */
        async function fetchLights(isAutoRefresh = false) {
            if (!LIFX_API_KEY) {
                if (!isAutoRefresh) showMessageBox('API Key Required', 'Please enter your LIFX API key to fetch lights.');
                return;
            }

            if (!isAutoRefresh) {
                apiKeyStatus.textContent = 'Fetching lights...';
                apiKeyStatus.classList.remove('text-red-600', 'text-green-600');
                apiKeyStatus.classList.add('text-gray-400');
            } else {
                 refreshStatusSpan.textContent = `Refreshing...`;
            }

            try {
                const response = await fetch('https://api.lifx.com/v1/lights/all', {
                    headers: {
                        'Authorization': `Bearer ${LIFX_API_KEY}`
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`LIFX API Error: ${response.status} - ${errorData.error || 'Unknown error'}`);
                }

                ALL_LIGHTS = await response.json();
                displayLights();

                if (!isAutoRefresh) {
                    apiKeyStatus.textContent = 'Lights fetched successfully!';
                    apiKeyStatus.classList.remove('text-gray-400');
                    apiKeyStatus.classList.add('text-green-500');
                    apiKeySetupSection.classList.add('hidden');
                    lightControlSection.classList.remove('hidden');
                    startAutoRefresh(); // Start refresh after initial success
                } else {
                    refreshStatusSpan.textContent = `Last refreshed: ${new Date().toLocaleTimeString()}`;
                }

            } catch (error) {
                console.error('Error fetching lights:', error);
                if (!isAutoRefresh) {
                    showMessageBox('Failed to Fetch Lights', `There was an error fetching your LIFX lights. Please check your API key and internet connection. Error: ${error.message}`);
                    apiKeyStatus.textContent = 'Failed to fetch lights. Invalid API Key or network issue.';
                    apiKeyStatus.classList.remove('text-gray-400', 'text-green-500');
                    apiKeyStatus.classList.add('text-red-500');
                    ALL_LIGHTS = [];
                    displayLights();
                    apiKeySetupSection.classList.remove('hidden');
                    lightControlSection.classList.add('hidden');
                } else {
                    refreshStatusSpan.textContent = `Refresh failed: ${new Date().toLocaleTimeString()}`;
                }
            }
        }

        /**
         * Sends a state change command to a single LIFX light.
         */
        async function sendLightCommand(lightId, payload) {
            if (!LIFX_API_KEY) {
                showMessageBox('API Key Missing', 'API key is not set. Please go to setup and save your key.');
                return;
            }

            const light = ALL_LIGHTS.find(l => l.id === lightId);
            if (!light || light.connected === false) {
                 showMessageBox('Light Unavailable', `Light "${light?.label || lightId}" is currently offline or unreachable.`);
                 return;
            }

            try {
                const response = await fetch(`https://api.lifx.com/v1/lights/id:${lightId}/state`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${LIFX_API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`LIFX API Error: ${response.status} - ${errorData.error || 'Unknown error'}`);
                }

                console.log(`Command sent to ${lightId}:`, payload);
            } catch (error) {
                console.error('Error sending light command:', error);
                showMessageBox('Command Failed', `Failed to send command to light. Error: ${error.message}`);
            }
        }
        
        // --- Auto-Refresh Functions ---
        
        /**
         * Starts the 60-second automatic refresh loop.
         */
        function startAutoRefresh() {
            if (refreshIntervalId) {
                clearInterval(refreshIntervalId);
            }
            // Set a new interval to fetch lights every 60 seconds (1 minute)
            refreshIntervalId = setInterval(() => fetchLights(true), 60000);
            refreshStatusSpan.textContent = `Last refreshed: ${new Date().toLocaleTimeString()}`;
        }


        // --- UI Rendering and Event Handlers ---

        /**
         * Updates the visual state of a single light card.
         */
        function updateLightCardVisuals(lightId) {
            const light = ALL_LIGHTS.find(l => l.id === lightId);
            if (!light) return;

            const card = document.getElementById(`card-${lightId}`);
            const slider = document.getElementById(`brightness-slider-${lightId}`);
            const sliderContainer = document.getElementById(`slider-container-${lightId}`);
            const brightnessValue = document.getElementById(`brightness-value-${lightId}`);
            const colorOverlay = document.getElementById(`color-overlay-${lightId}`);
            const statusPillElement = document.getElementById(`status-pill-${lightId}`);
            const colorButton = document.getElementById(`color-button-${lightId}`);
            const lightNameElement = card.querySelector('h3');
            const brightnessLabelElement = card.querySelector(`#brightness-label-${lightId}`);


            if (!card) return;

            card.classList.remove('bg-gray-700', 'bg-gray-800', 'opacity-50', 'cursor-pointer', 'shadow-sm', 'shadow-lg');
            card.classList.add('transition-all', 'duration-300');
            
            // Remove existing text color classes
            if (lightNameElement) {
                lightNameElement.classList.remove('text-gray-100', 'text-gray-900');
            }
            if (brightnessLabelElement) {
                brightnessLabelElement.classList.remove('text-gray-100', 'text-gray-900');
            }


            // 1. Check Connection Status (Offline)
            if (light.connected === false) {
                card.classList.add('bg-gray-700', 'opacity-50', 'cursor-not-allowed', 'shadow-sm');
                sliderContainer.classList.add('hidden');
                colorOverlay.style.backgroundColor = 'transparent';
                colorOverlay.style.opacity = '0';
                
                if (lightNameElement) lightNameElement.classList.add('text-gray-100'); // Ensure name is readable against gray-700
                if (brightnessLabelElement) brightnessLabelElement.classList.add('text-gray-100'); // Ensure brightness text is readable

                // Set Offline Pill
                statusPillElement.innerHTML = `
                    <span class="text-xs font-semibold px-3 py-1 rounded-full bg-red-800 text-red-300 flex items-center gap-1">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8.257 3.34c.52-1.258 2.45-1.258 2.97 0l6.234 15.01c.52 1.258-.39 2.47-1.554 2.47H3.577c-1.164 0-2.074-1.212-1.554-2.47L8.257 3.34zM10 13a1 1 0 100-2 1 1 0 000 2zm0-5a1 1 0 00-1 1v2a1 1 0 102 0V9a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                        OFFLINE
                    </span>
                `;
                colorButton.classList.add('opacity-50', 'cursor-not-allowed');
                colorButton.classList.remove('hover:scale-105');
                colorButton.style.backgroundColor = '#4b5563'; // Gray-600 equivalent
                return;
            }

            // 2. Connected Status
            colorButton.style.backgroundColor = '#8b5cf6'; // Default ON color (Purple-600)
            colorButton.classList.remove('opacity-50', 'cursor-not-allowed');
            colorButton.classList.add('hover:scale-105');

            if (light.power === 'off') {
                // Light is OFF (Connected)
                card.classList.add('bg-gray-700', 'cursor-pointer', 'shadow-sm');
                sliderContainer.classList.add('hidden');
                colorOverlay.style.backgroundColor = 'transparent';
                colorOverlay.style.opacity = '0';
                
                // Red Pill for OFF
                statusPillElement.innerHTML = `<span class="text-xs font-semibold px-3 py-1 rounded-full bg-red-800 text-red-300">OFF</span>`;
                
                // Disable icon button
                colorButton.classList.add('opacity-50', 'cursor-not-allowed');
                colorButton.classList.remove('hover:scale-105');
                colorButton.style.backgroundColor = '#4b5563'; // Gray-600
                if (lightNameElement) lightNameElement.classList.add('text-gray-100'); // Ensure name is readable against gray-700
                if (brightnessLabelElement) brightnessLabelElement.classList.add('text-gray-100'); // Ensure brightness text is readable

            } else {
                // Light is ON (Connected)
                card.classList.add('bg-gray-800', 'cursor-pointer', 'shadow-lg');
                sliderContainer.classList.remove('hidden');
                statusPillElement.innerHTML = ''; // Hide pill if ON
                
                // Update slider value and display
                const brightnessPercent = Math.round(light.brightness * 100);
                if (slider) slider.value = brightnessPercent;
                brightnessValue.textContent = `${brightnessPercent}%`;

                // Set color overlay
                const hue = light.color?.hue || 0;
                const sat = light.color?.saturation || 0;
                const brightness = light.brightness || 0;

                // Use HSB to RGB conversion to get the EXACT color representation
                const overlayColor = hsbToRgbCss(hue, sat, brightness);
                
                colorOverlay.style.backgroundColor = overlayColor;
                colorOverlay.style.opacity = '1'; // Set opacity to 1.0 since brightness is embedded in RGB
                
                // FIX 2: Dynamic contrast for device name and brightness text
                const textColorClass = getTextColorClass(brightness);
                if (lightNameElement) lightNameElement.classList.add(textColorClass);
                if (brightnessLabelElement) brightnessLabelElement.classList.add(textColorClass);
                
                // Enable color button only if ON
                colorButton.onclick = () => openColorPicker(light);
            }
        }


        /**
         * Renders the HTML for a single light card.
         */
        function renderLightCard(light) {
            const isConnected = light.connected !== false;
            const isOff = light.power === 'off';
            const brightnessPercent = Math.round(light.brightness * 100);

            // Determine initial visual styles and pill content
            let baseClass, cursorClass, initialPillHtml, sliderVisibility, iconButtonBg;

            if (isConnected) {
                cursorClass = 'cursor-pointer';
                if (isOff) {
                    baseClass = 'bg-gray-700 shadow-sm';
                    initialPillHtml = `<span class="text-xs font-semibold px-3 py-1 rounded-full bg-red-800 text-red-300">OFF</span>`;
                    sliderVisibility = 'hidden';
                    iconButtonBg = '#4b5563'; // Gray-600
                } else {
                    baseClass = 'bg-gray-800 shadow-lg';
                    initialPillHtml = ''; // Hidden if ON and connected
                    sliderVisibility = '';
                    iconButtonBg = '#8b5cf6'; // Purple-600
                }
            } else {
                baseClass = 'bg-gray-700 opacity-50 shadow-sm';
                cursorClass = 'cursor-not-allowed';
                sliderVisibility = 'hidden';
                iconButtonBg = '#4b5563';
                // Offline status pill
                initialPillHtml = `
                    <span class="text-xs font-semibold px-3 py-1 rounded-full bg-red-800 text-red-300 flex items-center gap-1">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8.257 3.34c.52-1.258 2.45-1.258 2.97 0l6.234 15.01c.52 1.258-.39 2.47-1.554 2.47H3.577c-1.164 0-2.074-1.212-1.554-2.47L8.257 3.34zM10 13a1 1 0 100-2 1 1 0 000 2zm0-5a1 1 0 00-1 1v2a1 1 0 102 0V9a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                        OFFLINE
                    </span>
                `;
            }

            // Calculate initial color overlay style
            let initialColorStyle = 'transparent';
            let initialOpacity = '0';
            let initialTextColorClass = 'text-gray-100'; // Default to white for off/dark background

            if (isConnected && !isOff) {
                const hue = light.color?.hue || 0;
                const sat = light.color?.saturation || 0;
                const brightness = light.brightness || 0;
                
                initialColorStyle = hsbToRgbCss(hue, sat, brightness);
                initialOpacity = '1'; // Set opacity to 1.0
                
                // Set initial text color based on initial brightness
                initialTextColorClass = getTextColorClass(brightness);
            }


            // The card container is the main clickable area for toggling power
            const cardHtml = `
                <div id="card-${light.id}"
                     data-light-id="${light.id}"
                     class="light-card-bg ${baseClass} ${cursorClass} p-5 rounded-xl border border-gray-600 transform hover:scale-[1.01] transition-all duration-300">
                    
                    <!-- Color/Brightness Overlay -->
                    <div id="color-overlay-${light.id}" class="light-color-overlay rounded-xl" style="background-color: ${initialColorStyle}; opacity: ${initialOpacity};"></div>

                    <!-- Main Content -->
                    <div class="relative z-10 space-y-3">
                        <div class="flex justify-between items-center mb-3">
                            <div id="status-pill-${light.id}">
                                ${initialPillHtml}
                            </div>
                        </div>

                        <div class="flex items-center justify-between">
                            <h3 class="text-xl font-bold ${initialTextColorClass} truncate pr-2">${light.label}</h3>
                            <!-- Colour Picker Icon Button -->
                            <button id="color-button-${light.id}" 
                                    data-light-id="${light.id}"
                                    title="Set Colour"
                                    style="background-color: ${iconButtonBg};"
                                    class="p-2 w-10 h-10 rounded-full shadow-md transition duration-300 ease-in-out inline-flex items-center justify-center
                                        ${isOff || !isConnected ? 'opacity-50 cursor-not-allowed' : 'hover:scale-105'}">
                                <!-- Color Wheel Icon SVG -->
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M12 2a10 10 0 1 0 10 10a10 10 0 0 0-10-10z"/>
                                    <path d="M18 10a6 6 0 0 0-6-6v6h6z"/>
                                    <path d="M12 18a6 6 0 0 1-6-6h6z"/>
                                </svg>
                            </button>
                        </div>
                        
                        <!-- Brightness Slider -->
                        <div id="slider-container-${light.id}" class="${sliderVisibility}">
                            <label for="brightness-slider-${light.id}" id="brightness-label-${light.id}" class="block text-sm font-medium ${initialTextColorClass} mb-2">
                                Brightness: <span id="brightness-value-${light.id}">${brightnessPercent}%</span>
                            </label>
                            <input type="range" id="brightness-slider-${light.id}" min="0" max="100" value="${brightnessPercent}"
                                   data-light-id="${light.id}"
                                   class="w-full h-3 bg-gray-600 rounded-lg appearance-none cursor-pointer transition duration-200">
                        </div>
                    </div>
                </div>
            `;
            return cardHtml;
        }

        /**
         * Displays the fetched lights in the dashboard grid.
         */
        function displayLights() {
            lightsListDiv.innerHTML = ''; // Clear previous list

            if (ALL_LIGHTS.length === 0) {
                noLightsMessage.classList.remove('hidden');
                return;
            } else {
                noLightsMessage.classList.add('hidden');
            }

            ALL_LIGHTS.forEach(light => {
                lightsListDiv.innerHTML += renderLightCard(light);
            });

            // Add event listeners after all cards are rendered
            ALL_LIGHTS.forEach(light => {
                const card = document.getElementById(`card-${light.id}`);
                const slider = document.getElementById(`brightness-slider-${light.id}`);
                const colorButton = document.getElementById(`color-button-${light.id}`);

                if (card && light.connected !== false) {
                    // Power toggle (click anywhere on the card)
                    card.addEventListener('click', (e) => {
                        // Prevent click event from firing when interacting with nested controls
                        if (e.target.closest('input[type="range"]') || e.target.closest('button')) {
                            return;
                        }
                        const newPowerState = light.power === 'on' ? 'off' : 'on';
                        handlePowerToggle(light.id, newPowerState);
                    });
                }
                
                if (slider) {
                    slider.addEventListener('input', (e) => {
                        handleBrightnessChange(light.id, e.target.value);
                    });
                    // Only apply on change/mouseup to prevent too many API calls while sliding
                    slider.addEventListener('change', (e) => {
                        handleBrightnessApply(light.id, e.target.value);
                    });
                }

                // Event listener for the new icon button
                if (colorButton && light.connected !== false) {
                    colorButton.addEventListener('click', () => {
                        // Re-check power state before opening modal
                        const currentLight = ALL_LIGHTS.find(l => l.id === light.id);
                        if (currentLight.power === 'on') {
                            openColorPicker(currentLight);
                        } else {
                             showMessageBox('Light is Off', `Please turn on ${currentLight.label} before setting its colour.`);
                        }
                    });
                }
            });
        }

        /**
         * Handles light power toggle.
         */
        async function handlePowerToggle(lightId, newState) {
            const light = ALL_LIGHTS.find(l => l.id === lightId);
            if (light.connected === false) return;

            // Optimistic update
            light.power = newState;
            // Update brightness locally if turning off, for consistency
            if (newState === 'off') {
                light.brightness = 0;
            }
            updateLightCardVisuals(lightId);

            // If turning ON, set brightness to 100% if it was 0
            let payload = { power: newState, duration: 0.3 };
            if (newState === 'on' && light.brightness === 0) {
                 payload.brightness = 1.0;
                 light.brightness = 1.0; // Update local state for visual update (if we turned it ON)
            }
            
            await sendLightCommand(lightId, payload);
            updateLightCardVisuals(lightId); // Re-update to reflect potential brightness change
        }

        /**
         * Handles immediate slider movement update (UI only).
         */
        function handleBrightnessChange(lightId, value) {
            const card = document.getElementById(`card-${lightId}`);
            const brightnessValue = document.getElementById(`brightness-value-${lightId}`);
            const colorOverlay = document.getElementById(`color-overlay-${lightId}`);
            const lightNameElement = card.querySelector('h3');
            // NEW: Get the brightness label element
            const brightnessLabelElement = card.querySelector(`#brightness-label-${lightId}`);

            if (brightnessValue) {
                brightnessValue.textContent = `${value}%`;
            }

            // Update local state and visual overlay instantly
            const light = ALL_LIGHTS.find(l => l.id === lightId);
            if (light) {
                const newBrightness = value / 100;
                light.brightness = newBrightness;
                
                // Update overlay with new brightness embedded in RGB
                const hue = light.color?.hue || 0;
                const sat = light.color?.saturation || 0;
                colorOverlay.style.backgroundColor = hsbToRgbCss(hue, sat, light.brightness);
                
                // Update text contrast dynamically
                const newTextColorClass = getTextColorClass(light.brightness);
                
                // Update light name contrast
                lightNameElement.classList.remove('text-gray-100', 'text-gray-900');
                lightNameElement.classList.add(newTextColorClass);

                // Update brightness label/value contrast
                if (brightnessLabelElement) {
                    brightnessLabelElement.classList.remove('text-gray-100', 'text-gray-900');
                    brightnessLabelElement.classList.add(newTextColorClass);
                }
            }
        }

        /**
         * Handles brightness value application (API call).
         */
        async function handleBrightnessApply(lightId, value) {
            const brightness = value / 100; // Convert 0-100 to 0.0-1.0
            
            const light = ALL_LIGHTS.find(l => l.id === lightId);
            let payload = { brightness: brightness, duration: 0.2 };

            // Crucial: If dragging from 0 to >0, ensure power is set to ON
            if (light.power === 'off' && brightness > 0) {
                payload.power = 'on';
                // Optimistic update of power state
                light.power = 'on'; 
                // We call updateLightCardVisuals *before* the API call for immediate feedback
                updateLightCardVisuals(lightId); 
            }
            
            await sendLightCommand(lightId, payload);
            // Auto-refresh or next action will validate the final state
        }

        // --- Event Listener Setup ---

        // Save API Key button click
        saveApiKeyBtn.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            if (key) {
                LIFX_API_KEY = key;
                localStorage.setItem('lifxApiKey', LIFX_API_KEY);
                fetchLights();
            } else {
                showMessageBox('API Key Empty', 'Please enter your LIFX API key before saving.');
            }
        });

        // Close message box
        messageBoxCloseBtn.addEventListener('click', hideMessageBox);

        // Color Picker Modal Control
        modalCloseBtn.addEventListener('click', () => {
            colorPickerModal.classList.add('hidden');
            ACTIVE_LIGHT_ID = null;
        });

        // Color Wheel Mouse/Touch Events (for modal)
        colorWheelCanvas.addEventListener('mousedown', (e) => {
            isDraggingColorWheel = true;
            handleColorSelection(e);
        });
        colorWheelCanvas.addEventListener('mousemove', (e) => {
            if (isDraggingColorWheel) {
                handleColorSelection(e);
            }
        });
        colorWheelCanvas.addEventListener('mouseup', () => {
            isDraggingColorWheel = false;
        });
        colorWheelCanvas.addEventListener('mouseleave', () => {
            isDraggingColorWheel = false;
        });

        colorWheelCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDraggingColorWheel = true;
            handleColorSelection(e);
        }, { passive: false });
        colorWheelCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDraggingColorWheel) {
                handleColorSelection(e);
            }
        }, { passive: false });
        colorWheelCanvas.addEventListener('touchend', () => {
            isDraggingColorWheel = false;
        });
        colorWheelCanvas.addEventListener('touchcancel', () => {
            isDraggingColorWheel = false;
        });


        // --- Initialization ---

        window.onload = () => {
            if (LIFX_API_KEY) {
                apiKeyInput.value = LIFX_API_KEY;
                fetchLights();
            }
        };
    </script>
</body>
</html>
